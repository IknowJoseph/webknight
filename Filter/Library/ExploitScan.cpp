/*
    AQTRONIX C++ Library
    Copyright 2005-2006 Parcifal Aertssen

    This file is part of AQTRONIX C++ Library.

    AQTRONIX C++ Library is free software; you can redistribute it
	and/or modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2 of
	the License, or (at your option) any later version.

    AQTRONIX C++ Library is distributed in the hope that it will be
	useful, but WITHOUT ANY WARRANTY; without even the implied warranty
    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with AQTRONIX C++ Library; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
    MA  02111-1307  USA
*/
// ExploitScan.cpp: implementation of the CExploitScan class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExploitScan.h"
#include "Url.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/* CHANGELOG
 *
 *	2005.07.14 Class created
 *  2007.05.04 Added IsObscure() and IsObscureQuerystring()
 */
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CExploitScan::CExploitScan()
{

}

CExploitScan::~CExploitScan()
{

}

bool CExploitScan::ScanHighBitShellCode(const char* ScanString)
{
	for(unsigned int i=0;i<strlen(ScanString);i++){
		if((unsigned char)ScanString[i]>127){
			return true;
		}
	}
	return false;
}

int CExploitScan::ScanSQLInjection(CString ScanString, const CStringList &SQLKeyWords, CStringList& Matches, bool NormalizeWhitespace, bool ReplaceNumericValuesWithOne)
{
	if(NormalizeWhitespace){
		ScanString.Replace(_T("/*"),_T(" /*")); //add spaces around the comments select/**/*/**/from
		ScanString.Replace(_T("*/"),_T("*/ "));
		ScanString.Replace(_T("#"),_T(" #")); //select%23%foobar%0A%09
		ScanString = RemoveRedundantWhitespace(ScanString);
	}
	if(ReplaceNumericValuesWithOne){
		ScanString.Replace(_T("true"),_T("1"));
		ScanString.Replace(_T("false"),_T("1"));
		ScanString = ScanString + _T(" _ ") + ReplaceNumeric(ScanString,'1'); //append, keep char(62),...
	}
	return CountKeywords(ScanString,SQLKeyWords,Matches);
}

bool CExploitScan::ScanParentPath(const CString& ScanString)
{
	if(ScanString.Find(_T(".."))==-1){
		return false;
	}else{
		return true;
	}
}

bool CExploitScan::ScanDirectoryTraversal(const CString& ScanString)
{
	if(ScanString.Find(_T("../"))!=-1 || ScanString.Find(_T("..\\"))!=-1 || ScanString.Find(_T("/.."))!=-1 || ScanString.Find(_T("\\.."))!=-1){
		return true;
	}else{
		return false;
	}
}

bool CExploitScan::ScanHexEncodingEmbedding(const CString& ScanString,const bool ConvertPlus)
{
	CString ScanDecodedString = CURL::URLEncodedToASCII(ScanString,true);
	return CanHexDecode(ScanDecodedString,ConvertPlus);
}

bool CExploitScan::CanHexDecode(const CString& ScanString, const bool ConvertAll)
{
	if(ScanString!=CURL::URLEncodedToASCII(ScanString,ConvertAll)){
		return true;
	}else{
		return false;
	}
}

bool CExploitScan::IsObscure(CString& Text, int MinimumLengthForScanning, LPCTSTR TheseCharsAreNotObscure)
{
	// > MinimumLength
	if(Text.GetLength()>MinimumLengthForScanning){
		//if specific characters are not present
		if(Text.FindOneOf(TheseCharsAreNotObscure)==-1){
			return true;
		}
	}
	return false;
}

bool CExploitScan::IsObscureQuerystring(CString &Querystring, int MinimumLength)
{
	return IsObscure(Querystring,MinimumLength,_T("=&;/_"));
}

bool CExploitScan::ScanVariableLength(CString& Data, int MaxLength, TCHAR Token1, TCHAR Token2)
{
	int count(0);
	int length = Data.GetLength();
	if(length>0 && length>MaxLength){
		TCHAR c;
		for(int i=0; i<length; i++){
			c = Data.GetAt(i);
			if(c==Token1 || c==Token2){
				if(count>MaxLength)
					return true;
				count = 0;
			}else{
				count++;
			}
		}
	}
	return count>MaxLength;
}

CString CExploitScan::RemoveRFCComments(CString& RFCString)
{
	int count(0);
	CString ret("");
	TCHAR c;
	int length = RFCString.GetLength();
	if(length>0){
		for(int i=0; i<length; i++){
			c = RFCString.GetAt(i);
			switch (c){
			case '(':
				count++;
				break;
			case ')':
				count--;
				break;
			default:
				{
					if(count==0){
						ret += c;
					}
					break;
				}
			}
			if(count<0){	//not good, exit loop and return original string
				return RFCString;
			}
		}

		//if error in comments, return original string
		if(count!=0){
			return RFCString;
		}
	}
	return ret;
}

CString CExploitScan::RemoveRedundantWhitespace(CString Text)
{
	CString ret("");

	int length = Text.GetLength();
	if(length>0){
		//normalize whitespace on single line
		LPTSTR buffer = Text.GetBuffer(0);
		for(int i=0; i<length; i++){
			if(buffer[i]<16 && buffer[i]>0) //https://github.com/sqlmapproject/sqlmap/blob/master/tamper/space2mssqlblank.py
				buffer[i]= ' ';
		}
		Text.ReleaseBuffer(length);

		ret = RemoveSpaces(Text," ()+&<=>.!");

		//remove double + ('++++++' and '+ + + +' concat works on MS Access and SQL Server)
		ret = RemoveDoubles(ret,'+');
	}

	return ret;
}

CString CExploitScan::RemoveSpaces(CString& Text, CString operators)
{
	CString ret("");
	int length = Text.GetLength();

	if(length>0){

		int i = 0;
		TCHAR c;
		TCHAR previous = Text.GetAt(i);
		i++;

		while(i<length){

			c = Text.GetAt(i);
			if(previous==' ' && operators.Find(c)!=-1){
				//space before operator
				previous = c; //skip space
			}else if(c==' ' && operators.Find(previous)!=-1){
				//space after previous, ignore
			}else{
				ret += previous;
				previous = c;
			}
			i++;
		}
		ret += previous;
	}

	return ret;
}

CString CExploitScan::RemoveDoubles(CString& Text, TCHAR c)
{
	CString ret("");
	int length = Text.GetLength();

	if(length>0){

		int i = 0;
		TCHAR current;
		TCHAR previous = Text.GetAt(i);
		i++;

		while(i<length){

			current = Text.GetAt(i);
			if(previous==c && current==c){
				//skip current
			}else{
				ret += previous;
				previous = current;
			}
			i++;
		}
		ret += previous;
	}

	return ret;
}

CString CExploitScan::ReplaceNumeric(CString& Text, TCHAR replacement)
{
	CString ret("");

	int length = Text.GetLength();
	if(length>0){
		TCHAR c;
		bool inNumber = false;
		for(int i=0; i<length; i++){
			c = Text.GetAt(i);
			if(c>47 && c<58){
				if(!inNumber)
					ret += replacement;
				inNumber = true;
			}else{
				inNumber = false;
				ret += c;
			}
		}
	}

	return ret;
}

bool CExploitScan::IsLengthAllowed(CString ContentLength, CString MaxLength)
{
	int cl = ContentLength.GetLength();
	int ml = MaxLength.GetLength();

	if(cl < ml)
		return true;

	if(cl > ml)
		return false;

	//equal length
	for(int i=0; i<cl; i++)
	{
		if(ContentLength.GetAt(i)<MaxLength.GetAt(i))
			return true;
		if(ContentLength.GetAt(i)>MaxLength.GetAt(i))
			return false;
	}

	return true;
}